% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
\documentclass[14pt]{matmex-diploma}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

%\documentclass[14pt]{matmex-diploma-custom}

\theoremstyle{definition}
\floatname{algorithm}{Алгоритм}
\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{corollary}{Следствие}
\newcommand{\overtext}[2]{\ensuremath{\stackrel{\mathrm{#1}}{\mathrm{#2}}}}
%\newtheorem{proof}{Доказательсво}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра системного программирования},
    title              = {Поиск кратчайшего пути с контекстно-свободными ограничениями в помеченном графе},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {coursework},
    position           = {студента},
    group              = 344,
    author             = {Антополь Валерий Алексеевич},
    supervisorPosition = {ст. преп.\,к. ф.-м. н.},
    supervisor         = {Григорьев С.\,В.},
    %reviewerPosition   = {ст. преп.},
    %reviewer           = {Привалов А.\,И.},
    %chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    %chairHead          = {Хунта К.\,Х.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
%\filltitle{en}{
%    chair              = {The Meaning of Life \\ Uselessness of Everything},
%    title              = {Empty subset as closed set},
%    author             = {Edelweis Mashkin},
%    supervisorPosition = {professor},
%    supervisor         = {Amvrosy Vibegallo},
%    reviewerPosition   = {assistant},
%    reviewer           = {Alexander Privalov},
%    chairHeadPosition  = {professor},
%    chairHead          = {Christobal Junta},
%}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
    Структуры данных на основе графов часто используются в различных областях, например, в биоинформатике, логистике, графовых базах данных, в языках программирования. Одна из таких структур --- это граф, каждому ребру которого сопоставляется символ из некоторого конечного алфавита $\Sigma$. Такой граф называется помеченным.
    
    Для того, чтобы получить информацию из графа, нужно выполнять запросы, задающие класс путей в графе. Пути рассматриваются в виде строки из меток на ребрах. Такие запросы удобно представлять в виде грамматики: путь удовлетворяет запросу, если он принадлежит языку, который порождает заданная грамматика. Часто результатом запроса должно являться отношение на вершинах графа: если (n, m) принадледжит отношению, то существует путь из n в m, который распознается грамматикой. Это называется задачей достижимости с контекстно-свободными ограниениями.
    
    В некоторых областях, например, в логистике, недостаточно найти какой-либо путь (или его существование) между парой вершин, нужно найти кратчайший (или его длину). Существуют различные алгоритмы поиска кратчайшего пути в графе с контекстно-свободными ограничениями. Но некоторые из них требуют отсутствия отрицательных весов~\cite{Barrett} или ацикличности графа~\cite{p2pdyck}.
    
    В 2017 году был предложен алгоритм решения задачи достижимости в произвольном помеченном графе с контекстно-свободными ограничениями~\cite{DBLP:journals/corr/AzimovG17}. Его особенность в том, что большая часть необходимих вычислений - это перемножение матриц, поэтому он легко параллелится на GPGPU~(General-Purpose computing on
Graphics Processing Units). 
    
    В данной работе описывается модификация этого алгоритма для решения задачи поиска кратчайшйх путей между каждой парой вершин с контекстно-свободными ограничениями. В отличие от других алгоритов, эта модификация имеет слабые ограничения: единственное условие на граф --- отсутствие циклов отрицательного веса.
    
    
    
%Помеченный граф - это граф, каждому ребру которого сопоставляется символ из некоторого алфавита $\Sigma$.
%\theoremstyle{definition}
%\begin{definition}
%    $(min, +)$-произведение двух числовых матриц $A$, $B$ - это %числовая матрица C, такая что $C_{i,j} = min_k\{A_{i,k} %+ B_{k,j}\}$
%\end{definition}
\section{Постановка задачи}
    Целью данной работы является модификация алгоритма решения задачи достижимости с контекстно-свободными ограничениями в помеченном графе~\cite{DBLP:journals/corr/AzimovG17} для решения задачи поиска кратчайшйх путей между каждой парой вершин с контекстно-свободными ограничениями. Для достижения данной цели были поставлены следующие задачи:
    \begin{itemize}
        \item создать модификацию алгоритма;
        \begin{itemize}
            \item доказать корректность;
            \item дать оценку времени работы;
        \end{itemize}
        \item провести экспериментальное исследование модифицированного алгоритма.
    \end{itemize}
\section{Обзор}
    \subsection{Fast-BJM}
        Алгоритм использует методы динамического программирования и очередь с приоритетами, за счет этого достигается время работы $O(|V|^3|N||P|)$, где $V$ --- множество ребер в графе, $N$ --- множество нетерминалов в грамматике, $P$ - множество правил вывода в грамматике. Не работает с ребрами отрицательного веса, также в графе не должно быть петель.
        Существует модификация этого алгоритма, позволяющая распараллеливание~\cite{D-Fast-BJM}. При распараллеливании на $|V|$ узлов каждый узел завершит работу за время $O(|V|^2|N||P|)$.
        Также существует модификация, имеющая ту же временную сложность, что и оригинальный алгоритм, но позволяющая работать с ребрами отрицательного веса~\cite{Johnson-Fast-BJM}. 
        
    \subsection{Fast Bounded-Difference Min-Plus Product}
        Этот алгоритм решает задачу, близкую к задаче поиска кратчайших путей с контекстно-свободными ограничениями.
        Отличие состоит в том, что вес есть не у ребер графа, а у правил вывода в грамматике~\cite{DBLP:journals/corr/BringmannGSW17}.
        Он состоит из построения транзитивного замыкания графа с помощью произведения матриц~\cite{VALIANT1975308}, в котором операции над элементами матрицы взяты из  $(min, +)$-произведения.
        За счет введения дополнительных ограничений на элементы перемножаемых матриц получается достичь $O(|V|^{2.8603})$ времени работы.

    \subsection{Context-Free Path Querying by Matrix Multiplication}
        В этой статье предложили алгоритм решения задачи достижимости с контекстно-свободными ограничениями с использованием транзитивного замыкания графа~\cite{VALIANT1975308}. Также в этой статье модифицировали алгоритм построения транзитивного замыкания, уменьшив объем вычислений. Именно этот алгоритм решения задачи достижимости и будет модифицироваться в данной работе.
        
\section{Модификация}
    \subsection{Исходный алгоритм}
        Пусть $(S, N,T,P)$ --- контекстно-свободная грамматика в нормальной форме Хомского, где $N$ --- множество нетерминалов, $T$ --- множество терминалов, $P$ --- множество правил вывода, $S$ --- стартовый нетерминал.\\
        Пусть $(V,E)$ --- помеченный ориентированный мультиграф, где $V$ --- множество вершин, $E \subset V \times T \times V$ --- множество рёбер.\\
        Алгоритм состоит в построении транзитивного замыкания матрицы смежности графа, поределяемым специальным образом.
        Элементами такой матрицы являются подмножества $N$. Пусть $a$ --- матрица смежности графа. Тогда если $A\in a_{i,j}$, то существует $i\pi j$ такой, что $w(\pi)\in~L(G_A)$, где $i\pi j$ --- путь в графе из вершины $i$ в вершину $j$, $w(\pi)$ --- слово, образуемое метками на пути $\pi$, $L(G)$ --- язык порожденный грамматикой $G$, $G_A$ --- грамматика, получающаяся из $G$ заменой стартового нетерминала на $A$.
        Введем операции на подмножествах N:
        \begin{equation*}
            N_1 \times N_2 = \{A~|~\exists B \in N,~\exists C \in N : A \rightarrow BC \in P\}
        \end{equation*}
        \begin{equation*}
            N_1 + N_2 = N_1 \cup N_2
        \end{equation*}
        Транзитивное замыкание матрицы $a$ определяется как $a^{cf} = \sum\limits_{i=1}^\infty a^{(i)}$, 
        где 
        \begin{equation*}
            a^{(i)} = 
            \begin{cases} 
                a,                                     & i=1\\
                a^{(i-1)} + a^{(i-1)}\times a^{(i-1)}, & i>1
            \end{cases}
        \end{equation*}

        
        Для транзитивного замыкания матрицы $a$ доказано~\cite{DBLP:journals/corr/AzimovG17} следующее:\\
        $A\in~a^{cf}_{i,j}$ тогда и только тогда, когда существует $i\pi j$ такой, что $w(\pi)\in~L(G_A)$.
        
        \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \caption{Решение задачи достижимости}
        \label{alg:graphParse}
        \Function{contextFreePathQuerying}{D - граф, G - грамматика}
            \State{$n \gets$ количество вершин в $D$}
            \State{$E \gets$ множество ребер в $D$}
            \State{$P \gets$ множество правил вывода в $G$}
            \State{$T \gets$ матрица размера $n \times n$, в которой каждый элемент равен $\varnothing$}
            \ForAll{$(i,x,j) \in E$}
            \Comment{Инициализация матрицы}
                \State{$T_{i,j} \gets T_{i,j} \cup \{A~|~(A \rightarrow x) \in P \}$}
            \EndFor    
            \While{матрица $T$ меняется}
                \State{$T \gets T \cup (T \times T)$}
                \Comment{Вычисление транзитивного замыкания $T$} 
            \EndWhile
        \State \Return $T$
        \EndFunction
        \end{algorithmic}
        \end{algorithm}
    \subsection{Модифицированный алгоритм}
        Множество ребер графа теперь является подмножеством $V \times T \times V \times \mathbb{R}$ --- у ребер графа появляется вес. Элементами используемой матрицы являются функции такого типа: $a_{i,j}: N\rightarrow\mathbb{R}\cup\{\infty\}$.\\
        На элементах матрицы водятся следующие операции:
        \begin{equation*}
            (N_1 \times N_2)(A) = \min\{N_1(B) + N_2(C)~|~A \rightarrow BC \in P\}
        \end{equation*}
        \begin{equation*}
            (N_1 + N_2)(A) = \min\{N_1(A), N_2(A)\}
        \end{equation*}
        Это в точности $(min, +)$-произведение.
        
        \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \caption{Решение задачи поиска кратчайших путей}
        \label{alg:graphParseShortest}
        \Function{contextFreePathQuerying}{D - граф, G - грамматика}
            \State{$n \gets$ количество вершин в $D$}
            \State{$E \gets$ множество ребер в $D$}
            \State{$P \gets$ множество правил вывода в $G$}
            \State{$T \gets$ матрица размера $n \times n$, $T_{i,j}(A) = \infty$}
            \ForAll{$(i,x,j,w) \in E$}
            \Comment{Инициализация матрицы}
                \ForAll{$A~|~(A\rightarrow x) \in P$}
                    \State{$T_{i,j}(A) \gets \min{(T_{i,j}(A),w})$}
                \EndFor
            \EndFor    
            \While{матрица $T$ меняется}
                \State{$T \gets T + (T \times T)$}
                \Comment{Вычисление транзитивного замыкания $T$ и поиск кратчайших путей} 
            \EndWhile
        \State \Return $T$
        \EndFunction
        \end{algorithmic}
        \end{algorithm}
    \subsection{Доказательство корректности}
        Для доказательства понадобятся следующие обозначения:\\
        Запись $i\pi j$ означает, что $\pi$ --- это путь в графе от вершины $i$ к вершине $j$.\\
        Запись $t \overtext{A}{\rightarrow} w$ означает, что $t$ --- дерево вывода слова $w$ из нетерминала $A$.\\ 
        $h(t)$ --- высота дерева $t$.\\
        $l(\pi)$ --- сумма весов ребер, входящих в путь $\pi$.\\
        $w(\pi), w(i\pi j)$ --- слово, образуемое конкатенацией меток на ребрах, входящих в путь $\pi$ в порядке прохождения.\\
        $T(i,A,j) = \{t~|~\exists i\pi j~:~t\overtext{A}{\rightarrow}w(i\pi j)$ -- множество деревьев вывода из $A$ слов на путях $i\pi j$
        $P(i,A,j) = \{i\pi j~|~\exists t~:~t\overtext{A}{\rightarrow}w(i\pi j)\}$\\
        $sl(i,A,j) = \min\{l(i\pi j)~|~i\pi j \in P(i,A,j)\}$\\
        $SP(i,A,j) = \{i\pi j~|~i\pi j \in P(i,A,j)~\land~l(i\pi j) = sl(i,A,j)\}$ --- множетво кратчайших путей из $i$ в $j$, таких что для каждого пути существует дерево вывода соотвествующего слова из $A$\\
        $ST(i,A,j) = \{t\in T(i,A,j)~|~\exists i\pi j\in SP(i,A,j): ~t\overtext{A}{\rightarrow}w(i\pi j)~\land~l(t) = sl(i,A,j)\}$ --- множество наименьших по высоте деревьев вывода слова $w(\pi)$ из $A$ для кратчайших путей $i\pi j$.\\
        $t_{left}$ --- левое поддерево дерева $t$, $t_{right}$ --- правое.\\
        Такак рассматриваемая грамматика в нормальной форме Хомского, деревья вывода имеют следующую структуру: нулевая высота --- в узле один терминал, высота равна единице --- в узле нетерминал, один потомок. Все узлы, располагающиеся на большей высоте имеют по два потомка-нетерминала.
        \begin{lemma}
        \label{sequence}
        Пусть $t \in ST(i,A,j),~h(t) > 1,~t_{left} \in T(i,B,r),~t_{right} \in T(r,C,j)$. Тогда либо $h(t_{left}) = h(t)-1$ и $t_{left} \in ST(i,B,r)$, либо $h(t_{right}) = h(t)-1$ и $t_{right} \in ST(r,C,j)$.
             
        \end{lemma}
        \begin{proof}
                Доказательство от противного.
                Предположим, что все поддеревья $t$ высоты $h(t)-1$ не принадлежат $ST(v,B,u)$ ни для каких $u,B,v$.
                Построим $t^{new} \in ST(i,A,j)$.
                Если $t_{left} \notin ST(i,B,r)$, в качесте $t^{new}_{left}$ возьмем произвольное дерево из $ST(i,B,r)$ и соответствующий путь $i\pi_2 r$, иначе $t^{new}_{left} = t_{left}$.
                По предположению $h(t^{new}_{left}) < h(t)-1$. Симметричные рассуждения проведем для $t_{right}$ и $t^{new}_{right}$.
                Пусть $i\pi_{left} r$ --- кратчайший путь из путей соответствующих левому дереву, $r\pi_{right}j$ - правому.
                Из условия леммы следует, что конкатенация путей $i\pi{left}r$ и $r\pi_{right}j$ --- путь, соответствующий $t^{new}$, при этом его длина не больше длины любоого пути, соответствующего $t$.
                Из этого и того,  что $t \in ST(i,A,j)$, следует, что $t^{new} \in ST(i,A,j)$. Но тот факт, что $h(t) > h(t^{new})$, противоречит тому, что все деревья в $ST(i,A,j)$ имеют одинаковую высоту. Следовательно предположение было неверным.
                Таким образом, лемма доказана.
        \end{proof}
        \begin{lemma}
            Алгоритм на $k$-той итерации хранит такую матрицу $T$, что $T_{i,j}(A) = \min\{Lenght(i\pi j)~|~\exists t \overtext{A}{\rightarrow} Word(i\pi j) \land h(t) <= i+1\}$
        \end{lemma}
        \begin{proof}
        Доказательтво по индукции.\\
        База.\\
        На итерации с номером 0 в , для которых существует дерево вывода высотой 1. Если путей существует несколько путей $i\pi j$, образующих слова, выводящиеся из одного нетерминала $A$ хранится только длина кратчайшего.\\
        Предположение.\\
            $k = n-1$\\
            $T_{i,j}(A) = \min\{l(i\pi j)~|~\exists t \overtext{A}{\rightarrow} w(i\pi j)~\land~h(t) <= k+1\}$
        Переход.
             
        \end{proof}
        \begin{theorem}
            Алгоритм 2 возвращает матрицу, такую, что $T_{i,j}(A) = sl(i,A,j)$
        \end{theorem}   
            
        \begin{proof}
            Рассмотрим  $T = \bigcup_{i,j \in V, A \in N}ST(i,A,j)$. Пусть $t \in T$
            По Лемме \ref{sequence} если $h(t) > 1$, существует $t_{new} \in T$ такое, что $h(t_{new}) = h(t)-1$. Таким образом, можно составить последовательность $\{t_i\}^{h(t)}_{i=1}$ такую, что $t_i \in T \land h(t_i) = i$
            
           По Лемме 4.1\cite{DBLP:journals/corr/AzimovG17} алгоритм на итерации с номером $i$ 
        \end{proof}
    \subsection{Оценка времени работы}
\section{Экспериментальное исследование}
    
 %У заключения нет номера главы
\section*{Заключение}
    В данной работе модифицирован алгоритм поиска пути с контекстно-свободными %ограничениями в помеченном графе\cite{DBLP:journals/corr/AzimovG17} для поиска %кратчайшего пути. Для достижения данной цели были решены следующие задачи:
    \begin{itemize}
        \item алгоритм модифицирован с помощью $(min, +)$-произведения;
        \begin{itemize}
            \item доказана корректность;
            \item дана оценка времени работы: $O(e^{|V||E||N|})$;
        \end{itemize}
        \item проведено экспериментальное исследование модифицированного алгоритма;
    \end{itemize}
    
\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
